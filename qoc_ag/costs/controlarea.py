"""
controlarea.py - This module defines a cost function that penalizes
the "area under the curve" of the control parameters.
"""
import autograd.numpy as anp
from numpy import ndarray


class ControlArea():
    """
    This cost penalizes the area under the
    function of time generated by the discrete control parameters.

    Parameters
    ----------
    control_num:
        Number of control Hamiltonians
    total_time_steps
    cost_multiplier:
        Weight factor of the cost function; expected < 1
    max_control_norms:
        Length is control_num. Maximum allowed area for each control; expected > 0
    """
    name = "control_area"
    requires_step_evaluation = False

    def __init__(self, control_num: int,
                 total_time_steps: int,
                 cost_multiplier: float = 1.,
                 max_area: ndarray = None, ) -> None:

        self.cost_multiplier = cost_multiplier
        self.control_num = control_num
        self.control_size = control_num * total_time_steps
        self.max_area = max_area
        self.type = "control_explicitly_related"

    def cost(self, controls: ndarray)-> float:
        """
        Compute the penalty.

        Parameters
        ----------
        controls:
            Every control amplitude. Shape is (control_num, toltal_time_steps)
        """
        cost = 0
        if self.max_area is None:

            normalized_controls = controls
            # The cost is the discrete integral of each normalized control parameter
            # over the evolution time.
            for i in range(self.control_num):
                cost = cost + anp.abs(anp.sum(normalized_controls[i]))
            cost_normalized = cost / self.control_size
        else:
            for i in range(self.control_num):
                power = anp.abs(anp.sum(controls[:, i]))
                if power > self.max_area[i]:
                    cost = cost + anp.abs(anp.sum(controls[i]))
                cost = cost - self.max_area[i]
            cost_normalized = cost / anp.sum(controls)

        return cost_normalized * self.cost_multiplier
